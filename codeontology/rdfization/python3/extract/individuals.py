"""Classes and methods to create and instantiate ontology individuals."""

from __future__ import annotations

from typing import List, Tuple, Type, Union

import astroid

from codeontology.ontology import ontology
from codeontology.rdfization.python3.explore import Project, Library, Package
from codeontology.rdfization.python3.extract.utils import get_parent_node, BLOCK_NODES


class OntologyIndividuals:
    """Class to initialize the individuals from the ontology.
    Has a collection of methods, one for every class in the ontology.
    Upon creating the individual and properly appending it to the node, it instantiate the basic properties that can
    be determined by the attributes of the node itself (so no properties that involve two different individuals or
    data properties whose value depends on more than 1 AST node). The other kind of properties are instantiated by the
    extractor itself.

    TODO !!! Using automatically generated IRIs for individuals! Default IRIs are generated simply by postponing a
     progressive number `N` to the lowercase class name `OntologyClass`, such as `ontologyclassN`. This way individuals
     are distinguishable only between individuals extracted from the same run! To make them mixable with other
     individuals generated by different projects in different executions, we need to assign truly unique IRIs. I think
     of two possible solutions:
      - the more robust one, which requires more effort, is to define a rule that mixes the unique properties of each
         individual to generate a unique IRI. We have to write this rule manually for each class though.
      - use a `Globally Unique Identifier (GUID)` generator to generate IRIs that are very unlikely to be generated a
         second time, although this is still possible, making this solution not very robust. The function `uuid.uuid4()`
         could be used.

    """

    """Other parameters."""

    START_POSITION_COUNT: int = 0
    START_LINE_COUNT: int = 1

    """Static individuals."""

    PUBLIC_ACCESS_MODIFIER: ontology.AccessModifier = ontology.AccessModifier("PythonPublic")
    PROTECTED_ACCESS_MODIFIER: ontology.AccessModifier = ontology.AccessModifier("PythonProtected")
    PRIVATE_ACCESS_MODIFIER: ontology.AccessModifier = ontology.AccessModifier("PythonPrivate")

    """Methods for individual initialization."""

    @staticmethod
    def init_code_element():
        pass

    @staticmethod
    def init_annotation():
        pass

    # --- Start Executable related -------------------------------------------------------------------------------------

    @staticmethod
    def init_executable(
            function_node: Union[astroid.FunctionDef, astroid.AsyncFunctionDef],
            ontology_type: Union[Type[ontology.Constructor], Type[ontology.Function], Type[ontology.Method]]
    ):
        if not hasattr(function_node, "individual"):
            assert not hasattr(function_node, "stmt_individual")
            assert not hasattr(function_node, "stmt_block_individual")

            function_node.individual = ontology_type()
            OntologyIndividuals.init_declaration_statement(function_node)
            OntologyIndividuals.init_block_statement(function_node)

            function_node.stmt_individual.hasBody = function_node.stmt_block_individual
            assert function_node.stmt_individual == function_node.stmt_block_individual.isBodyOf

            function_node.individual.hasDeclaration = function_node.stmt_individual

            if hasattr(function_node, "is_var_args"):
                function_node.individual.isVarArgs = function_node.is_var_args

            function_node.individual.hasSourceCode = function_node.as_string()

            if hasattr(function_node, "description") and function_node.description is not None:
                function_node.individual.hasDocumentation.append(function_node.description)

    @staticmethod
    def init_constructor(function_node: Union[astroid.FunctionDef, astroid.AsyncFunctionDef]):
        if not hasattr(function_node, "individual"):
            OntologyIndividuals.init_executable(function_node, ontology.Constructor)

    @staticmethod
    def init_function(function_node: Union[astroid.FunctionDef, astroid.AsyncFunctionDef]):
        if not hasattr(function_node, "individual"):
            OntologyIndividuals.init_executable(function_node, ontology.Function)
            function_node.individual.hasSimpleName = function_node.name

    @staticmethod
    def init_method(function_node: Union[astroid.FunctionDef, astroid.AsyncFunctionDef]):
        if not hasattr(function_node, "individual"):
            OntologyIndividuals.init_executable(function_node, ontology.Method)
            function_node.individual.hasName = function_node.name

    # --- End Executable related ---------------------------------------------------------------------------------------

    @staticmethod
    def init_executable_argument():
        pass

    # --- Start Expression related -------------------------------------------------------------------------------------

    @staticmethod
    def init_expression(
            expression_node: astroid.NodeNG,
            expr_type: Type[ontology.Expression] = ontology.Expression
    ):
        if not hasattr(expression_node, "expr_individual"):
            expression_node.expr_individual = expr_type()
            assert isinstance(expression_node.expr_individual, expr_type)
            expression_node.expr_individual.hasSourceCode = expression_node.as_string()
            expression_node.expr_individual.hasLine = expression_node.lineno + OntologyIndividuals.START_LINE_COUNT - 1

    @staticmethod
    def init_assignment_expression(assign_node: Union[astroid.Assign, astroid.AnnAssign, astroid.AugAssign]):
        if not hasattr(assign_node, "expr_individual"):
            OntologyIndividuals.init_expression(assign_node, expr_type=ontology.AssignmentExpression)

    @staticmethod
    def init_executable_invocation_expression(call_node: astroid.Call):
        if not hasattr(call_node, "expr_individual"):
            OntologyIndividuals.init_expression(call_node, expr_type=ontology.ExecutableInvocationExpression)
            # TODO probably need more info

    @staticmethod
    def init_class_instance_creation_expression(call_node: astroid.Call):
        if not hasattr(call_node, "expr_individual"):
            pass

    @staticmethod
    def init_function_invocation_expression(call_node: astroid.Call):
        if not hasattr(call_node, "expr_individual"):
            pass

    @staticmethod
    def init_method_invocation_expression(call_node: astroid.Call):
        if not hasattr(call_node, "expr_individual"):
            pass

    @staticmethod
    def init_lambda_expression(lambda_expression_node: astroid.Lambda):
        if not hasattr(lambda_expression_node, "expr_individual"):
            OntologyIndividuals.init_expression(lambda_expression_node, expr_type=ontology.LambdaExpression)

    @staticmethod
    def init_lambda_invocation_expression():
        pass

    # --- End Expression related ---------------------------------------------------------------------------------------

    @staticmethod
    def init_left_value():
        pass

    @staticmethod
    def init_modifiable():
        pass

    # --- Start Modifier related ---------------------------------------------------------------------------------------

    @staticmethod
    def init_modifier():
        pass

    @staticmethod
    def init_access_modifier():
        pass

    # --- End Modifier related -----------------------------------------------------------------------------------------

    @staticmethod
    def init_package(package: Package):
        if not hasattr(package, "individual"):
            package.individual = ontology.Package()

            package.individual.hasSimpleName = package.simple_name
            package.individual.hasFullyQualifiedName = package.full_name

            if not hasattr(package.library, "individual"):
                OntologyIndividuals.init_library(package.library)
            package.individual.hasLibrary = package.library.individual
            assert package.individual in package.library.individual.isLibraryOf

            # package.individual.hasSourceCode = package.ast.as_string()
            if hasattr(package.ast, "description") and package.ast.description is not None:
                package.individual.hasDocumentation.append(package.ast.description)

    # --- Start Statement related --------------------------------------------------------------------------------------

    @staticmethod
    def init_statement(
            stmt_node: astroid.NodeNG,
            stmt_type: Type[ontology.Statement] = ontology.Statement,
            true_stmt_node: astroid.NodeNG = None,
            stmt_attr: str = "stmt_individual"
    ):
        # The `ref_node` is the real statement, but `node` is where we store the information! We do this because some
        #  statements may simultaneously have multiple meanings, even of different kinds, such as an example:
        #  >>> a = b = 0
        # It is a single statement, but declaring two variables, so we extract from there two
        #  `VariableDeclarationStatements`: the `ref_node` is of `astroid.Assign`, but we store the two separate
        #  declaration statement individuals in its child of type `astroid.AssignName`, that are behind our `node`.
        # We obviously later link the statements as equivalent (same individual) with `owlready2.set_equivalent_to`, and
        #  we can get them back with `owlready2.get_equivalent_to`.
        if not hasattr(stmt_node, stmt_attr):
            if true_stmt_node is None:
                true_stmt_node = stmt_node
            else:
                assert not stmt_node.is_statement
            assert true_stmt_node.is_statement

            setattr(stmt_node, stmt_attr, stmt_type())
            assert isinstance(getattr(stmt_node, stmt_attr), stmt_type)
            getattr(stmt_node, stmt_attr).hasSourceCode = true_stmt_node.as_string()
            if true_stmt_node.lineno:
                getattr(stmt_node, stmt_attr).hasLine = true_stmt_node.lineno + OntologyIndividuals.START_LINE_COUNT - 1
            if true_stmt_node is not stmt_node:
                if not hasattr(true_stmt_node, "stmt_individual"):
                    OntologyIndividuals.init_statement(true_stmt_node)
                true_stmt_node.stmt_individual.set_equivalent_to([getattr(stmt_node, stmt_attr)])
                assert true_stmt_node.stmt_individual not in getattr(stmt_node, stmt_attr).get_equivalent_to()

            parent_block_stmt_individual = get_parent_block_individual(stmt_node)
            if parent_block_stmt_individual is not None:
                parent_block_stmt_individual.hasSubStatement.append(getattr(stmt_node, stmt_attr))
                assert parent_block_stmt_individual == getattr(stmt_node, stmt_attr).isSubStatementOf

    @staticmethod
    def init_assert_statement(assert_node: astroid.Assert):
        if not hasattr(assert_node, "stmt_individual"):
            OntologyIndividuals.init_statement(assert_node, stmt_type=ontology.AssertStatement)

    @staticmethod
    def init_block_statement(node: astroid.NodeNG, stmt_attr: str = "stmt_block_individual"):
        if not hasattr(node, stmt_attr):
            OntologyIndividuals.init_statement(node, stmt_type=ontology.BlockStatement, stmt_attr=stmt_attr)
            stmt_individual = getattr(node, stmt_attr)
            if type(node) is astroid.If:
                if stmt_attr == "stmt_block_then_individual":
                    if node.body[-1].end_lineno is not None:
                        stmt_individual.hasEndLine = node.body[-1].end_lineno
                else:
                    assert stmt_attr == "stmt_block_else_individual"
                    if node.orelse[-1].end_lineno is not None:
                        stmt_individual.hasEndLine = node.orelse[-1].end_lineno
            else:
                if node.end_lineno is not None:
                    stmt_individual.hasEndLine = node.end_lineno

    @staticmethod
    def init_labeled_block():
        pass

    @staticmethod
    def init_case_labeled_block():
        pass

    @staticmethod
    def init_default_labeled_block():
        pass

    @staticmethod
    def init_control_flow_statement():
        pass

    @staticmethod
    def init_branching_statement(
            branching_node: Union[astroid.Break, astroid.Continue, astroid.Return],
            stmt_type: Type[ontology.BranchingStatement] = ontology.BranchingStatement,
    ):
        if not hasattr(branching_node, "stmt_individual"):
            OntologyIndividuals.init_statement(branching_node, stmt_type=stmt_type)

    @staticmethod
    def init_break_statement(break_node: astroid.Break):
        if not hasattr(break_node, "stmt_individual"):
            OntologyIndividuals.init_branching_statement(break_node, stmt_type=ontology.BreakStatement)

    @staticmethod
    def init_continue_statement(continue_node: astroid.Continue):
        if not hasattr(continue_node, "stmt_individual"):
            OntologyIndividuals.init_branching_statement(continue_node, stmt_type=ontology.ContinueStatement)

    @staticmethod
    def init_return_statement(return_node: astroid.Return):
        if not hasattr(return_node, "stmt_individual"):
            OntologyIndividuals.init_branching_statement(return_node, stmt_type=ontology.ReturnStatement)

    @staticmethod
    def init_decision_making_statement():
        pass

    @staticmethod
    def init_if_then_else_statement(if_node: astroid.If):
        if not hasattr(if_node, "stmt_individual"):
            OntologyIndividuals.init_statement(if_node, stmt_type=ontology.IfThenElseStatement)
            OntologyIndividuals.init_block_statement(if_node, stmt_attr="stmt_block_then_individual")

            if_node.stmt_individual.hasThenBranch = if_node.stmt_block_then_individual
            assert if_node.stmt_individual == if_node.stmt_block_then_individual.isThenBranchOf

            if not if_node.has_elif_block() and if_node.orelse:
                OntologyIndividuals.init_block_statement(if_node, stmt_attr="stmt_block_else_individual")

                if_node.stmt_individual.hasElseBranch = if_node.stmt_block_else_individual
                assert if_node.stmt_individual == if_node.stmt_block_else_individual.isElseBranchOf

    @staticmethod
    def init_switch_statement():
        pass

    @staticmethod
    def init_loop_statement(
            loop_node: Union[astroid.While, astroid.For],
            stmt_type: Type[ontology.LoopStatement] = ontology.LoopStatement,
    ):
        OntologyIndividuals.init_statement(loop_node, stmt_type=stmt_type)

    @staticmethod
    def init_do_while_statement():
        # Not in Python.
        pass

    @staticmethod
    def init_for_statement():
        # Not in Python.
        pass

    @staticmethod
    def init_for_each_statement(for_node: astroid.For):
        if not hasattr(for_node, "stmt_individual"):
            assert not hasattr(for_node, "stmt_block_individual")
            OntologyIndividuals.init_loop_statement(for_node, stmt_type=ontology.ForEachStatement)
            OntologyIndividuals.init_block_statement(for_node)

            for_node.stmt_individual.hasBody = for_node.stmt_block_individual
            assert for_node.stmt_individual == for_node.stmt_block_individual.isBodyOf

    @staticmethod
    def init_while_statement(while_node: astroid.While):
        if not hasattr(while_node, "stmt_individual"):
            assert not hasattr(while_node, "stmt_block_individual")
            OntologyIndividuals.init_loop_statement(while_node, stmt_type=ontology.WhileStatement)
            OntologyIndividuals.init_block_statement(while_node)

            while_node.stmt_individual.hasBody = while_node.stmt_block_individual
            assert while_node.stmt_individual == while_node.stmt_block_individual.isBodyOf

    @staticmethod
    def init_declaration_statement(
            node: astroid.NodeNG,
            ref_node: astroid.NodeNG = None,
            stmt_type: Type[ontology.DeclarationStatement] = ontology.DeclarationStatement
    ):
        OntologyIndividuals.init_statement(node, true_stmt_node=ref_node, stmt_type=stmt_type)

    @staticmethod
    def init_variable_declaration_statement():
        pass

    @staticmethod
    def init_field_declaration_statement(field_declaration_node: Union[astroid.AssignName, astroid.AssignAttr]):
        assign_parent = get_parent_node(field_declaration_node, {astroid.Assign, astroid.AnnAssign})
        assert type(assign_parent) in [astroid.Assign, astroid.AnnAssign]
        OntologyIndividuals.init_declaration_statement(
            field_declaration_node, ref_node=assign_parent, stmt_type=ontology.FieldDeclarationStatement
        )

    @staticmethod
    def init_global_variable_declaration_statement(var_node: astroid.AssignName):
        assign_parent = get_parent_node(var_node, {astroid.Assign, astroid.AnnAssign})
        assert type(assign_parent) in [astroid.Assign, astroid.AnnAssign]
        OntologyIndividuals.init_declaration_statement(
            var_node, ref_node=assign_parent, stmt_type=ontology.GlobalVariableDeclarationStatement
        )

    @staticmethod
    def init_local_variable_declaration_statement(var_node: astroid.AssignName):
        # ??? What about variables declared by `for loops` or `with statements`, or `except`s
        ref_node = var_node.scope()
        OntologyIndividuals.init_declaration_statement(
            var_node, ref_node=ref_node, stmt_type=ontology.LocalVariableDeclarationStatement
        )

    @staticmethod
    def init_exception_handling_statement():
        pass

    @staticmethod
    def init_catch_statement(except_node: astroid.ExceptHandler):
        if not hasattr(except_node, "stmt_individual"):
            assert not hasattr(except_node, "stmt_block_individual")
            OntologyIndividuals.init_statement(except_node, stmt_type=ontology.CatchStatement)
            OntologyIndividuals.init_block_statement(except_node)

            except_node.stmt_individual.hasBody = except_node.stmt_block_individual
            assert except_node.stmt_individual == except_node.stmt_block_individual.isBodyOf

    @staticmethod
    def init_finally_statement(try_finally_node: astroid.TryFinally):
        if not hasattr(try_finally_node, "stmt_finally_individual"):
            assert not hasattr(try_finally_node, "stmt_block_individual")
            # !!! Could need to adjust line number, not really distinguishing between the `try` and `finally` blocks
            OntologyIndividuals.init_statement(
                try_finally_node, stmt_type=ontology.FinallyStatement, stmt_attr="stmt_finally_individual")
            OntologyIndividuals.init_block_statement(try_finally_node)

            try_finally_node.stmt_finally_individual.hasBody = try_finally_node.stmt_block_individual
            assert try_finally_node.stmt_finally_individual == try_finally_node.stmt_block_individual.isBodyOf

    @staticmethod
    def init_try_statement(try_except_finally_node: Union[astroid.TryFinally, astroid.TryExcept]):
        if not hasattr(try_except_finally_node, "stmt_try_individual"):
            assert not hasattr(try_except_finally_node, "stmt_block_individual")
            # !!! Could need to adjust line number, not really distinguishing between the `try` and `finally` blocks
            OntologyIndividuals.init_statement(
                try_except_finally_node, stmt_type=ontology.TryStatement, stmt_attr="stmt_try_individual")
            OntologyIndividuals.init_block_statement(try_except_finally_node)

            try_except_finally_node.stmt_try_individual.hasBody = try_except_finally_node.stmt_block_individual
            assert try_except_finally_node.stmt_try_individual == try_except_finally_node.stmt_block_individual.isBodyOf

    @staticmethod
    def init_expression_statement(expr_node: astroid.Expr):
        if not hasattr(expr_node, "stmt_individual"):
            OntologyIndividuals.init_statement(expr_node, stmt_type=ontology.ExpressionStatement)

    @staticmethod
    def init_import_statement(import_node: Union[astroid.Import, astroid.ImportFrom]):
        OntologyIndividuals.init_statement(import_node, stmt_type=ontology.ImportStatement)

    @staticmethod
    def init_synchronized_statement():
        pass

    @staticmethod
    def init_throw_statement():
        pass

    # --- End Statement related ----------------------------------------------------------------------------------------

    # --- Start Type related -------------------------------------------------------------------------------------------

    @staticmethod
    def init_type():
        # With no use, we directly use `Class`es and `Parameterized Type`s.
        pass

    @staticmethod
    def init_array_type():
        # Not in Python.
        pass

    @staticmethod
    def init_complex_type():
        # With no use, we directly use `Class`es.
        pass

    @staticmethod
    def init_anonymous_class():
        # Not in Python.
        pass

    @staticmethod
    def init_class(class_node: astroid.ClassDef):
        # The only Type we use along with `Parameterized Type`.
        if not hasattr(class_node, "individual"):
            assert not hasattr(class_node, "stmt_individual")
            assert not hasattr(class_node, "stmt_block_individual")

            class_node.individual = ontology.Class()
            OntologyIndividuals.init_declaration_statement(class_node)
            OntologyIndividuals.init_block_statement(class_node)

            class_node.stmt_individual.declares.append(class_node.individual)

            class_node.individual.hasModifier.append(OntologyIndividuals.PUBLIC_ACCESS_MODIFIER)

            class_node.individual.hasSimpleName = class_node.name

            if hasattr(class_node, "description") and class_node.description is not None:
                class_node.individual.hasDocumentation.append(class_node.description)

    @staticmethod
    def init_enum():
        # It is not a native concept in Python, and can only be simulated by inheriting from `enum.Enum`. However, the
        #  definition remains the one of a `Class`, that is the only concept we use.
        pass

    @staticmethod
    def init_interface():
        # Not in Python.
        pass

    @staticmethod
    def init_parameterized_type(generic_individual: ontology.Class, parameterized_individuals: List) -> \
            ontology.ParameterizedType:
        # It is not a native concept in Python, and can only be simulated using annotations and the `typing` module`.
        #  Although there are no `generic`s, some classes such as `list`, `dictionary` or `set` can be instantiated with
        #  arbitrary types. Since annotations may allow us to describe the specific `parameterization` we are using in a
        #  specific context (such as `list[str]`), we try to model this concept anyway so that we do not lose this
        #  precious information.
        assert type(generic_individual) is ontology.Class and type(parameterized_individuals) is list
        parameterized_type_individual = ontology.ParameterizedType()
        parameterized_type_individual.hasGenericType = generic_individual
        for i, individual in enumerate(parameterized_individuals):
            OntologyIndividuals.init_type_argument(parameterized_type_individual, individual, i)

        return parameterized_type_individual

    @staticmethod
    def init_primitive_type():
        # In Python the `Built-in Type`s are considerable `Primitive Type`s. However, they are still `Classes`, with
        # fields and methods, and we decided to model them as such, so this method is never used.
        pass

    @staticmethod
    def init_type_variable():
        # It is not a native concept in Python, and can only be simulated using the `typing` module`. However, the
        #  object remains an instance of a `Class` (`Type`) from the `typing` module, that is the only concept we use.
        pass

    @staticmethod
    def init_wildcard():
        # Not in Python, maybe can be simulated using the `typing` module`, but I don't know.
        pass

    # --- End Type related ---------------------------------------------------------------------------------------------

    @staticmethod
    def init_type_argument(
            parameterized_type: ontology.ParameterizedType,
            parameterization_type: Union[ontology.Class, ontology.ParameterizedType, List],
            parameterization_pos: int
    ):
        assert type(parameterized_type) is ontology.ParameterizedType
        assert type(parameterization_type) in [ontology.Class, ontology.ParameterizedType, list, type(None)]
        if type(parameterization_type) is not list:
            parameterization_type = [parameterization_type]

        type_argument_individual = ontology.TypeArgument()
        type_argument_individual.isActualTypeArgumentOf = parameterized_type
        assert type_argument_individual in parameterized_type.hasActualTypeArgument
        for param_type in parameterization_type:
            assert type(param_type) in [ontology.Class, ontology.ParameterizedType, type(None)]
            if type(param_type) is not type(None):
                type_argument_individual.hasArgumentType.append(param_type)
                assert type_argument_individual in param_type.isArgumentTypeOf
        type_argument_individual.hasTypeArgumentPosition = parameterization_pos

    # --- Start Variable related ---------------------------------------------------------------------------------------

    @staticmethod
    def init_variable():
        pass

    @staticmethod
    def init_field(
            field_name: str,
            field_description: Union[str, None],
            field_declaration_node: Union[astroid.AssignName, astroid.AssignAttr],
            class_node: astroid.ClassDef
    ):
        if not hasattr(field_declaration_node, "individual"):
            assert not hasattr(field_declaration_node, "stmt_individual")

            field_declaration_node.individual = ontology.Field()
            OntologyIndividuals.init_field_declaration_statement(field_declaration_node)

            field_declaration_node.individual.hasVariableDeclaration = field_declaration_node.stmt_individual

            field_declaration_node.individual.hasName = field_name

            field_declaration_node.individual.isDeclaredBy.append(class_node.individual)
            assert field_declaration_node.individual in class_node.individual.declares

            field_declaration_node.individual.isFieldOf = class_node.individual
            assert field_declaration_node.individual in class_node.individual.hasField

            if field_description is not None:
                field_declaration_node.individual.hasDocumentation.append(field_description)

    @staticmethod
    def init_global_variable(var_node: astroid.AssignName, module_node: astroid.Module):
        if not hasattr(var_node, "individual"):
            assert not hasattr(var_node, "stmt_individual")

            var_node.individual = ontology.GlobalVariable()
            OntologyIndividuals.init_global_variable_declaration_statement(var_node)

            var_node.individual.hasVariableDeclaration = var_node.stmt_individual

            var_node.individual.hasSimpleName = var_node.name

            if hasattr(module_node, "package_"):
                var_node.individual.hasPackage = module_node.package_.individual
                assert var_node.individual in module_node.package_.individual.isPackageOf

                var_node.individual.hasFullyQualifiedName = \
                    f"{module_node.package_.individual.hasFullyQualifiedName}.{var_node.name}"

    @staticmethod
    def init_local_variable(var_node: astroid.AssignName,
                            fun_node: Union[astroid.FunctionDef, astroid.AsyncFunctionDef]):
        if not hasattr(var_node, "individual"):
            assert not hasattr(var_node, "stmt_individual")

            var_node.individual = ontology.LocalVariable()
            OntologyIndividuals.init_local_variable_declaration_statement(var_node)

            var_node.individual.hasVariableDeclaration = var_node.stmt_individual

            var_node.individual.hasName = var_node.name

            var_node.individual.isDeclaredBy.append(fun_node.individual)
            assert var_node.individual in fun_node.individual.declares

    @staticmethod
    def init_parameter(
            param_name: str, param_pos: Union[int, None], param_type: Union[astroid.ClassDef, List, Tuple, None],
            param_description: Union[str, None], param_is_vararg: bool, param_is_pos_only: bool, param_is_key_only: bool
    ) -> ontology.Parameter:
        parameter_individual = ontology.Parameter()

        parameter_individual.hasName = param_name
        if param_pos is not None:
            assert not (param_is_vararg or param_is_key_only)
            parameter_individual.hasParameterPosition = OntologyIndividuals.START_POSITION_COUNT + param_pos
        if param_description is not None:
            parameter_individual.hasDocumentation.append(param_description)
        parameter_individual.isVarArgs = param_is_vararg
        parameter_individual.isPositionalOnly = param_is_pos_only
        parameter_individual.isKeywordOnly = param_is_key_only

        return parameter_individual

    # --- End Variable related -----------------------------------------------------------------------------------------

    @staticmethod
    def init_library(library: Library):
        library.individual = ontology.Library()

        library.individual.hasName = library.name

        if library.is_by_project:
            library.individual.hasProject = library.project.individual
            assert library.individual in library.project.individual.isProjectOf
            library.individual.isDependencyOf.append(library.project.individual)
            assert library.individual in library.project.individual.hasDependency

    @staticmethod
    def init_project(project: Project):
        project.individual = ontology.Project()

        project.individual.hasName = project.name
        # TODO `project.individual.hasBuildFile`, retrieving the content of the setup file
        # TODO `project.individual.hasComment`, retrieving the description from the setup file


def get_parent_block_individual(node: astroid.NodeNG) -> Union[ontology.BlockStatement, None]:
    """TOCOMMENT find parent node for block-statement relations"""
    parent_block_node = get_parent_node(node, BLOCK_NODES)
    parent_block_individual = None

    if type(parent_block_node) is astroid.If:
        if node in parent_block_node.body:
            parent_block_individual = getattr(parent_block_node, "stmt_block_then_individual", None)
        else:
            assert node in parent_block_node.orelse
            parent_block_individual = getattr(parent_block_node, "stmt_block_else_individual", None)
    elif type(parent_block_node) is astroid.Module:
        if hasattr(parent_block_node, "ast"):
            parent_block_individual = getattr(parent_block_node.ast, "package_", None)
    elif parent_block_node is not None:
        parent_block_individual = getattr(parent_block_node, "stmt_block_individual", None)

    return parent_block_individual
